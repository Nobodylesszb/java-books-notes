# 并发编程的其他基础知识

## 2.1什么是多线程并发编程

首先要澄清并发和并行的概念，并发是指同 一个时间段内多个任务同时都在执行，并 且都没有执行结束，而并行是说在单位时间 内 多个任务同时在执行 。 并发任务强调在 一个 时间段内同时执行，而一个时间段由多个单位时间累积而成，所以说并发的多个任务在单 位时间内不 一 定同时在执行 。 在单 CPU 的时代多个任务都是并发执行的，这是因为单个 CPU 同时只能执行一个任务。 在单 CPU 时代多任务是共享一个 CPU 的，当一个任务占用 CPU 运行时，其他任务就会被挂起，当占用 CPU 的任务时间片用完后，会把 CPU 让给其 他任务来使用，所以在单 CPU 时代多线程编程是没有太大意义的，并且线程间频繁的上 下文切换还会带来额外开销 。

而在多线程编程实践中，线程的个数往往多于 CPU 的个数，所 以一般都称多线程并发编程而不是多线程并行编程。

## 2.2为什么要进行多线程并发编程

多核CPU时代的到来打破了单核CPU对多线程效能的限制。 多个CPU意味着每个 线程可以使用自己的 CPU 运行，这减少了线程上下文切换的开销，但随着对应用系统性 能和吞吐量要求的提高，出现了处理海量数据和请求的要求，这些都对高并发编程有着迫 切的需求 。

## 2.3java中的线程安全问题

谈到线程安全问题，我们先说说什么是共享资源 。 所谓共享资源，就是说该资源被多个线程所持有或者说多个线程都可以去访问该资源 。
 线程安全 问题是指当 多个线程同时读写 一个共享资源并且没有任何同步措施时，导致出现脏数据或者其他不可预见的结果的问题，如图所示。

![image-20200503213614330](https://gitee.com/nobodylesszb/upic/raw/pic/upload/pics/1588512974-image-20200503213614330.png)

在图中：线程 A 和线程 B 可以同时操作主内存中的共享变量，那么线程安全问 题和共享资源之间是什么关系呢?是不是说多个线程共享了资源 ， 当它们都去访 问这个共 享资源时就会产生线程安全问题呢?答案是否定的 ， 如果多个线程都只是读取共享资源 ， 而不去修改，那么就不会存在线程安全 问题 ， 只有当至少一个线程修改共享资源时才会存 在线程安全 问题。最典型的就是计数器类的实现，计数变量 count本身是一个共享变量， 多个线程可以对其进行递增操作，如果不使用同步措施 ， 由于递增操作是获取一计算一保 存 三步 操作 ， 因此可能导致计数不准确，如下所示

![image-20200503213712235](https://gitee.com/nobodylesszb/upic/raw/pic/upload/pics/1588513032-image-20200503213712235.png)

假如当前count=O，在tl时刻线程A读取count值到本地变量countA。 然后在t2时 刻递增 countA 的值为 l，同时线程 B 读取 count 的值 0 到本地变量 countB，此时 countB 的值为 0 (因为 countA 的值还没有被写入主内存)。在 t3 时刻线程 A 才把 countA 的值 1 写入主内存 ， 至此线程 A 一 次计数完毕，同时线程 B 递增 CountB 的值为 1。 在 t4 时刻 线程 B 把 countB 的值 l 写入内存，至此线程 B 一次计数完毕。这里先不考虑 内存可见性 问题 ， 明明是两次计数，为何最后结果是 l 而不是 2 呢?其实这就是共享变量的线程安全 问题。那么如何来解决这个问题呢?这就需要在线程访问共享变量时进行适当的 同步，在 Java 中最常见的是使用关键宇 synchronized 进行同步，下面会有具体介绍。

## 2.4java中共享变量的内存可见性问题

谈到内存可见性， 我们首先来看看在多线程下处理共享变量时 Java的内存模型，如图 所示。

![image-20200503214708351](https://gitee.com/nobodylesszb/upic/raw/pic/upload/pics/1588513628-image-20200503214708351.png)

Java 内存模型规定，将所有的变量都存放在主内存中，当线程使用变量时，会把主内 存里面的变量复制到自己的工作空间或者叫作工作内存，线程读写变量时操作的是自己工 作内存中的变量。 Java 内存模型是一个抽象的概念，那么在实际实现中线程的工作内存是 什么呢?请看图

![image-20200503214736044](https://gitee.com/nobodylesszb/upic/raw/pic/upload/pics/1588513656-image-20200503214736044.png)

图中所示是一个双核 CPU系统架构，每个核有自己的控制器和运算器，其中控制器 包含 一组寄 存器和操作控制 器，运算器执 行算术逻辅运算 。每 个核都有自己的 一 级缓存， 在有些架构里面还有一个所有 CPU 都共享的二级缓存。 那么 Java 内存模型里面的工作内 存，就对应这里的 Ll 或者 L2 缓存或者 CPU 的寄存器。

当一个线程操作共享变量时， 它首先从主内存复制共享变量到自己的工作内存， 然后 对工作 内存里 的变量进行处理， 处理完后将变量值更新到主 内存。

那么假如线程 A 和线程 B 同时处理一个共享变量 ， 会出现什么情况?我们使用图 2-5 所示CPU架构， 假设线程A和线程B使用不同CPU执行，并且当前两级Cache都为空， 那么这时候由于 Cache 的存在，将会导致内存不可见 问题 ， 具体看下面的分析。

· 线程A首先获取共享变量X的值，由于两级Cache都没有命中，所以加载主内存 中 X 的值，假如为 0。然后把 X=O 的值缓存到两级缓存 ， 线程 A 修改 X 的值为 1, 然后将其写入两级 Cache， 并且刷新到主内存 。 线程 A 操作完毕后，线程 A 所在的 CPU 的两级 Cache 内和主内存里面的 X 的值都是 l。

· 线程 B 获取 X 的值，首先一级缓存没有命中，然后看二级缓存，二级缓存命中了 ， 所以返回X=1; 到这里一切都是正常的， 因为这时候主内存中也是X=l。然后线 程 B 修改 X 的值为 2， 并将其存放到线程 2 所在 的 一 级 Cache 和共享二级 Cache 中， 最后更新主内存中X的值为2: 到这里一切都是好的。

· 线程A这次又需要修改X的值， 获取时一级缓存命中， 并且X=l，到这里问题就 出现了，明明线程 B 已经把 X 的值修改为了 2，为何线程 A 获取的还是 l 呢? 这 就是共享变量的内存不可见 问 题 ， 也就是线程 B 写入的值对线程 A 不可见。

那么如何解决共享变量内存不可见问题? 使用 Java 中的 volatile关键字就可 以解决这个 问题,

## 2.5Java 中 的 synchronized 关 键 字

### 2.5.1synchronized 关键字介绍

synchronized块是 Java提供的一种原子性内置锁， Java中的每个对象都可以把它当作 一个同步锁来使用 ， 这些 Java 内置的使用者看不到的锁被称为内部锁，也叫作监视器锁。 线程的执行代码在进入 synchronized 代码块前会自动获取内部锁，这时候其他线程访 问 该 同步代码块时会被阻塞挂起 。拿到内部锁的线程会在正常退出同步代码块或者抛出 异常后 或者在同步块内调用了该内置锁资源的wait系列方法时释放该内置锁。 内置锁是排它锁， 也就是当一个线程获取这个锁后 ， 其他线程必须等待该线程释放锁后才能获取该锁 

另外，由于 Java 中的线程是与操作系统的原生线程 一一 对应的，所以当阻塞 一个线 程时，需要从用户态切换到内核态执行阻塞操作，这是很耗时的操作，而 synchronized 的 使用就会导致上下文切换。

### 2.5.2synchronized 的内存语义

前面介绍了共享变量 内存可见性问题主要是由于线程的工作内存导致的，下面我们来 讲解 synchronized 的一个内存语义，这个内存语义就可以解决共享变量内存可见性问题 。 进入 synchronized 块的内存语义是把在 synchronized 块内使用到的变量从线程的工作内存 中清除，这样在 synchronized 块内使用到该变 量 时就不会从线程的工作内存中获取，而是 直接从主内存中获取 。 退出 synchronized 块的内存语义是把在 synchronized 块内对共享变 量 的修改刷新到主内存 。

其实这也是加锁和释放锁的语义，当获取锁后会清空锁块内本地内存中将会被用到的 共享变量，在使用这些共享变量时从主 内存进行加载，在释放锁时将本地内存中修改的共 享变量刷新到主内存 。

除可以解决共享变 量 内存可见性问题外， synchronized 经常被用来实现原子性操作 。 另外请注意， synchronized 关键字会引起线程上下文切换并带来线程调度开销 。

## 2.6Java 中的 volatile 关键字

上面介绍了使用锁的方式可以解决共享变量 内存可见性问题，但是使用锁太笨重，因 为它会带来线程上下文的切换开销 。 对于解决内存可见性问题， Java 还提供了 一种弱形式 的同步，也就是使用 volatile 关键字 。 该关键 字 可以确保对 一 个变 量 的更新对其他线程马 上可见 。 当一个变量被声明为 volatile 时，线程在写入变量时不会把值缓存在寄存器或者 其他地方，而是会把值刷新回主内存 。 当其 他 线程读取该共享变 量 时-，会从主内存重新获 取最新值，而不是使用当前线程的工作内存中的值。 volatile的内存语义和 synchronized有 相似之处，具体来说就是，当线程写入了 volatile 变量值时就等价于线程退出 synchronized 同步块(把写入工作内存的变量值同步到主内存)，读取 volatile变量值时就相当于进入同 步块 (先清空本地内存变量值，再从主内存获取最新值)。

下面看一个使用 volatile关键字解决内存可见性问题的例子 。 如下代码中的共享变量value 是线程不安全的 ，因 为这里没有使用适当的同步措施。

```java
public class ThreadNotSafeinteger (
  private int value; 
  public int get() {
	return value;
  }
  public vo工d set(int value) { 
    this.value =value;
  }
  }

```

首先来看使用 synchronized 关键宇进行 同步的方式 。

```java
public class threadsafeInterger{
  privite int value;
  public synchronized int get(){
    return value
      
  }
  public synchronized void set (工口t value) { 
    this .value = value;
  }
  
}
```

然后是使用 volatile进行同步。

```java
public class threadsafeInterger{
  privite volatile int value;
  public  int get(){
    return value
      
  }
  public  void set (工口t value) { 
    this .value = value;
  }
  
}
```

在这里使用 synchronized 和使用 volatile 是等价的，都解决了共享变量 value 的内存可 见性问题，但是前者是独占锁，同时只能有一个线程调用 get()方法，其他调用线程会被阻塞 ， 同时会存在线程上下文切换和线程重新调度的开销，这也是使用锁方式不好的地方。 而后 者是非阻塞算法， 不会造成线程上下文切换的开销 

但并非在所有情况下使用它们都是 等价的， volatile 虽然提供了可见性保证，但并不 保证操作的原子性 。

那么一般在什么时候才使用 volatile关键字呢?

- 写入变量值不依赖、变量的当前值时 。 因为如果依赖当前值，将是获取一计算一写入 三步操作，这三步操作不是原子性的，而 volatile不保证原子性。
- 读写 变量值时 没有加锁 。 因为加锁本身已经保证了内存可见性，这时候不 需要把变 量声 明为 volatile 的 。

## 2.7 java中的原子操作

所谓原子性操作，是指执行一系列操作时，这些操作要么全部执行 ， 要么全部不执行， 不存在只执行其中一部分的情况。 在设计计数器时一般都先读取当前值，然后+l， 再更新。 这个过程是 读 改 写 的过程，如果不能保证这个过程是原子性的，那么就会出现线程安 全问题。 如下代码是线程不安全的，因为不能保证++value是原子性操作。

```java
public class threadNotSafeThreadCountP{
  private long value;
  public long getcount(){
    return value;
  }
  public void inc(){
    ++value;
  }
}
```

那么如何才能保证 多个操作的原子性呢?最简单的方法就是使用 进行同步，修改代码如下 。

```java
public class threadNotSafeThreadCountP{
  private long value;
  public synchronized long getcount(){
    return value;
  }
  public synchronized void inc(){
    ++value;
  }
}
```

使用 synchronized 关键宇的确可以实现线程安全性 ，即内存可见性和原子性, synchronized 是独占锁，没有获取内部锁的线程会被阻 塞掉 ，而这 里的 getCount 方法只是 读操作，多个线程同时调用不会存在线程安全问题 。 但是加了关键宇 synchronized 后，同 一时间就只能有一个线程可以调用，这显然大大降低了并发性 。 你也许会间，既然是只读 操作，那为何不去掉 getCount 方法上的 synchronized 关键字呢?其实是不能去掉的，别忘 了这里要靠 synchronized来实现 value的内存可见性。那么有没有更好的实现呢?答案是 肯定的，下面将讲到的在内部使用非阻塞 CAS算法实现的原子性操作类 AtomicLong就是 一个不错的选择 。

## 2.8java中的cas操作

在 Java 中 ， 锁在并发处理中占据了 一 席之地，但是使用锁有 一 个不好的地方，就 是当 一个线程没有获取到锁时会被阻塞挂起 ， 这会导致线程上下文的切换和重新调度开 销 。 Java 提供了非阻塞的 volatile 关键字来解决共享变量的可见性问题 ， 这在 一 定程度 上弥补 了 锁带来的开销 问 题，但是 volatile 只能保 证 共享变 量 的 可见性，不能解决读 改一写等的原子性问题。 CAS即CompareandSwap，其是JDK提供的非阻塞原子性操 作 ， 它通过硬件保证了 比较 更新操作的原子 性 。 JDK 里面的 Unsafe 类提供了一系列的 compareAndSwap*方法 ， 下面以 compareAndSwapLong 方法为例进行简单介绍 。

- boolean compareAndSwapLong(Object obj,long valueOffset,long expect, long update)方 法:其中compareAndSwap的意思是比较并交换。CAS有四个操作数， 分别为:对 象内存位置 、 对象中 的变量的偏移量 、 变量预期值和新的值 。 其操作含义是 ， 如果 对象 obj 中内存偏移量为 valueOffset的变量值为 expect，则使用新的值 update替换 旧的值 expect。 这是处理器提供的一个原子性指令。

关于CAS操作有个经典的ABA问题， 具体如下: 假如线程I使用CAS修改初始值 为A的变量X， 那么线程I会首先去获取当前变量X的值(为A〕， 然后使用CAS操作尝 试修改 X 的值为 B，如果使用 CAS 操作成功了，那么程序运行一定是正确的吗?其实未必， 这是因为有可能在线程 I 获取变 量 X 的值 A 后，在执行 CAS 前，线程 II 使用 CAS 修改 了变量X的值为B，然后又使用CAS修改了变量X的值为A。 所以虽然线程I执行CAS 时X的值是A， 但是这个A己经不是线程I获取时的A了。 这就是ABA问题。

ABA 问题 的产生是因为变量 的状态值产生 了环形转换，就是变量的值可 以从 A 到 B, 然后再从 B 到 A。如果变量的值只能朝着一个方向转换 ，比如 A 到 B, B 到 C， 不构成环 形，就不会存在 问题。 JDK 中 的 AtomicStampedReference 类给每个变量 的状态值都配备了 一个时间戳， 从而避免了ABA问题的产生。

## 2.9 Unsafe 类

### 2.9.1Unsafe类的重要方法

JDK的此jar包中的Unsafe类提供了硬件级别的原子性操作， Unsafe类中的方法都是 native方法，它们使用刑I的方式访问本地C++实现库。 下面我们来了解一下Unsafe提供的几个主要的方法以及编程时如何使用 Unsafe类做一些事情。

- longobjectFieldOffset(Field白eld)方法 :返回指定的变量在所属类中的内存偏移地址，该偏移地址仅仅在该 Unsafe 函数中访 问指定宇段时使用。 如下代码使用 Unsafe 类获取变量 value 在 AtomicLong 对象 中的内存偏移 。

```java
static{
  try{
    valueOffset = unsafe.objectFieldOffset(
    AtomicLong.class.getDeclaredField(”value"));
                                      
  }catch(Exception ex){
    throw new error(ex);
  }
}
```



- int anayBaseOffset(Class anayClass)方法 : 获取数组中第一个元素的地址。 
- intarraylndexScale(ClassarrayClass)方法 : 获取数组中一个元素占用的字节。 
- boolean compareAndSwapLong(Object obj, long offset, long expect, long update) 方法 :比较对象 obj 中偏移量为 offset的变量的值是否与 expect相等， 相等则使用 update 值更新， 然后返回 true，否则返回 false。
- public native long getLongvolatile(Object obj, long offset) 方法 : 获取 对 象 obj 中 偏移 量为 offset 的变量对应 volatile i吾义的值 。

- void putLongvolatile(Object obj , long offset, long value)方 法 : 设置 obj 对 象 中 offset 偏移的类型为 long的 field的值为 value，支持 volatile语义。
- void putOrderedLong(Object obj , long offset, long value) 方法 : 设置 obj 对象 中 offset 偏移地址对应的 long型 field 的值为 value。 这是一个有延迟的 putLongvolatile方法， 并且不保证值修改对其他线程立刻可见。 只有在变量使用 volatile修饰并且预计会 被意外修改时才使用该方法。

- void park(boolean isAbsolute, long time) 方法 : 阻塞 当 前 线程 ， 其 中 参数 isAbsolute 等于 false且 time等于 0表示一直阻塞。 time大于 0表示等待指定的 time后阻塞线 程会被唤醒， 这个 time是个相对值， 是个增量值， 也就是相对当前时间累加 time 后当前线程就会被唤醒。 如果 isAbsolute等于 true， 并且 time大于 0，则表示阻塞 的线程到指定的时间点后会被唤醒，这里 time是个绝对时间， 是将某个时间点换 算为 ms后的值。 另外，当其他线程调用了当前阻塞线程的 intem1pt方法而中断了 当前线程时-， 当前线程也会返回， 而当其他线程调用 了 unPark方法并且把当前线 程作为 参数 时 当 前 线程 也 会返 回 。

## 2.10java指令重排序

Java 内存模型允许编译器和处理器对指令重排序以提高运行性能， 并且只会对不存在 数据依赖性的指令重排序。 在单线程下重排序可以保证最终执行的结果与程序顺序执行的 结果一致，但是在多线程下就会存在问题 。

## 2.11伪共享

### 2.11什么是伪共享

为了解决计算机系统中主内存与 CPU 之间运行速度差问题，会在 CPU 与主内存之间 添加一级或者多级高速缓冲存储器( Cache)。这个 Cache 一般是被集成到 CPU 内部的， 所以也叫 CPU Cache，图 所示是两级 Cache 结构。

![image-20200503223053126](https://gitee.com/nobodylesszb/upic/raw/pic/upload/pics/1588516253-image-20200503223053126.png)

在 Cache 内部是按行存储的，其中每一行称为一个 Cache行。 Cache行(如图所示) 是 Cache 与主内存进行数据交换的单位， Cache 行的大小一般为 2 的幕次数字节。

![image-20200503223121089](https://gitee.com/nobodylesszb/upic/raw/pic/upload/pics/1588516281-image-20200503223121089.png)

当 CPU 访问某个变 量 时，首先会去看 CPU Cache 内是否有该变量，如果有则直接从 中获取，否则就去主内存里面获取该变 量 ，然后把该变量所在内存区域的一个 Cache 行大 小的内存复制到 Cache 中。 由于存放到 Cache行的是内存块而不是单个变量，所以可能会把多个变量存放到一个 Cache行中。 当多个线程同时修改一个缓存行里面的多个变量时， 由于同时只能有 一 个线程操作缓存行 ，所以相比将 每个变 量放到 一 个缓存行，性能会有所 下降，这就是伪共享

![image-20200503223356537](https://gitee.com/nobodylesszb/upic/raw/pic/upload/pics/1588516436-image-20200503223356537.png)

在该图中，变量 x和 y 同时被放到了 CPU 的一级和二级缓存，当线程1对变 量 x 进行更新时 ，首先会修改 CPUl 的一级缓存变 量 x 所在的缓存行，这时候在缓存 一致性协议下， CPU2 中变量 x对应的缓存行失效。那么线程 2在写入变量 x时就只能去 二级缓存里查找，这就破坏了 一级缓存。而一级缓存 比二级缓存更快 ，这也说明了 多个线 程不可能同时去修改自己所使用的 CPU中相同缓存行里面的变量。更坏的情况是，如果 CPU 只有一级缓存，则会导致频繁地访问主内存 。

### 2.11.2为何会出现伪共享

伪共享的产生是因为 多个变量被放入了一个缓存行中，并且多个线程 同时去写入缓存 行中不同的变量 。那么 为何 多个变量会被放入 一个缓存行呢?其实是 因为缓存与内存交换 数据 的单位就是缓存行 ， 当 CPU 要访问的变量没有在缓存中找到时，根据程序运行的局会把该变量所在内存中大小为缓存行的内存放入缓存行。

`long a; long  b; long c; long d;`

如上代码声明了四个 long变量，假设缓存行的大小为 32字节， 那么当 CPU访问变 量 a 时 ， 发现该变量没有在缓存中，就会去主内存把变量 a 以及内存地址附近的 b、 c、 d 放入缓存行。也就是地址连续的多个变量才有可能会被放到一个缓存行中。当创建数组时， 数组里面的多个元素就会被放入同一 个 缓存 行 。那么在单线程下多个变量被放入同一个缓 存行对性能有影响吗?其实在正常情况下单线程访 问时将数组元素放入一个或者多个缓存 行对代码执行是有利的，因为数据都在缓存 中 ，代码执行会更快，

### 2.11.3如何避免伪共享

在 JDK 8 之前 一般都是通过字节填充的方 式来避免该问题，也就是创建 一个变量时使 用填充字段填充该变量所在的缓存行，这样就避免了将多个变量存放在同 一个缓存行中， 例如如下代码 

```java
 public final static class FilledLong { 
   public volatile long value = 0L; 
	public long pl, p2, p3, p4, pS, p6;
 }

```

假如缓存行为 64 宇节 ，那么我们在 FilledLong 类里 面 填充 了 6 个 long 类型的变 量， 每个long类型变量占用8字节， 加上value变量的8字节总共56字节。另外， 这里 FilledLong是一个类对象， 而类对象的字节码的对象头占用 8字节，所以一个 FilledLong 对象实际会占用 64字节的内存，这正好可以放入一个缓存行。

JDK 8提供了一个 sun.misc.Contended注解，用来解决伪共享问题。将上面代码修改 为如下。

```java
@sun.misc.Contended
public final static class FilledLong {
public volatile long val ue = OL;
}
```

## 2.12锁定概述

### 2.12.1乐观锁和悲观锁

乐观锁和悲观锁是在数据库中引入的名词，但是在并发包锁里面也引入了类似的思想， 所以这里还是有必要讲解下 。

悲观锁指对 数据被外界修改持保守态度 ，认为数据 很容易就会被其 他线 程修改 ，所以 在数据被处理前先对数据进行加锁，并在整个数据处理过程中，使数据处于锁定状态 。 悲 观锁的 实 现往往依 靠数据库提供 的锁机制，即在数据 库 中 ，在对数据记录操作前给记录 加 排它锁。 如果获取锁失败， 则说明数据正在被其他线程修改， 当前线程则等待或者抛出异 常。 如果 获取 锁成功，则对记 录进行操作 ，然 后提交事务后释放 排它锁 。

乐观锁并不会使用数据库提供的锁机制， 一般在表中添加 version 宇段或者使用业务 状态来实现 。 乐观锁直到提交时才锁定，所以不会产生任何死锁 。

### 2.12.2公平锁和非公平锁

根据线程获取锁的抢占机制，锁可以分为公平锁和非 公平锁，公平锁表示线程获取锁 的顺序是按照线程请求锁的时间早晚来决定的，也就是最早请求锁的线程将最早获取到锁。 而非公平锁 则在运行时闯入，也就是先来不 一 定先得 。

ReentrantLock 提供了公 平和非公平锁的实现 。

- 公平锁: ReentrantLockpairLock =new ReentrantLock(true)。
- 非公平锁: ReentrantLockpairLock=newReentrantLock(false)。 如果构造函数不传

递参数，则默认是非公平锁 。

例如，假设线程 A 已经持有了锁，这时候线程 B 请求该锁其将会被挂起。 当线程 A 释放锁后，假如 当前有线程 C 也需要获取该锁，如果采用非公平锁方式，则根据线程调度 策略， 线程 B 和线程 C 两者之一可能获取锁，这时候不需要任何其他干涉，而如果使用 公平锁则需要把 C 挂起，让 B 获取当前锁 。

在没有公平性需求的前提下尽量使用非公平锁，因为公平锁会带来性能开销 。

### 2.12.3独占锁和共享锁

根据锁只能被单个线程持有还是能被多个线程共同持有，锁可以分为独占锁和共享锁 

独占锁保证任何时候都只有 一个线程能得到锁， ReentrantLock 就是以独占方式实现 的。 共享锁则可以同时由多个线程持有 ，例如 ReadWriteLock 读写锁，它允许一个资源可 以被 多 线程同时进行读操作 。

独占锁是 一种悲观锁，由于每次访问资源都先加上互斥锁，这限制了并发性，因为读 操作并不会影响数据的 一 致性 ，而独占 锁只允许在同 一 时间由 一 个线程读取数据，其他线 程必须等待当前线程释放锁才能进行读取 。

共享锁则是一种乐观锁，它放宽了加锁的条件，允许多个线程同时进行读操作 。

### 2.12.4什么是可重入锁

当一个线程要获取 一个被其他线程持有的独占锁时，该线程会被阻塞，那么当 一个线 程再次获取它自己己经获取的锁时是否会被阻塞呢?如果不被阻塞，那么我们说该锁是可 重入的，也就是只要该线程获取了该锁，那么可以无限次数(在高级篇中我们将知道，严 格来说是有限次数)地进入被该锁锁住的代码 。

下面看一个例子，看看在什么情况下会使用可重入锁 。

```java
public class Hello{
public synchronized void helloA () {
System.out.println( ” h e l lo ”);
}
public synchronized void he lloB () {
  System.out.println(”hello B”); helloA();
}
}

```

在如上代码中，调用 helloB 方法前会先获取内置锁，然后打印输出。之后调用 helloA 方法，在调用前会先去获取内置锁，如果内置锁不是可重入的，那么调用线程将会 一直被 阻 塞。

实际上， synchronized 内 部锁是可重入锁 。 可重入锁的原理是在锁内部维护 一 个线程 标示，用来标示该锁目前被哪个线程占用，然后关联一个计数器。一开始计数器值为 o, 说明该锁没有被任何线程占用 。 当一个钱程获取了该锁时，计数器的值会变成 1，这时其他线程再来获取 该锁时会发现锁的所有者不是自己而被阻塞挂起。

但是当获取了该锁的线程再次获取锁时发现锁拥有者是自己，就会把计数器值加+ 1, 当释放锁后计数器值 -1。 当计数器值为 0 时-，锁里面的线程标示被重置为 null， 这时候被 阻塞的线程会被唤醒来竞争获取该锁 。

### 2.12.5自旋锁

由于 Java 中的线程是与操作系统中的线程一一对应的，所以当 一个线程在获取锁(比 如独占锁)失败后，会被切换到内核状态而被挂起 。 当该线程获取到锁时又需要将其切换 到内核状态而唤醒该线程 。 而从用户状态切换到内核状态的开销是比较大的，在 一 定程度 上会影响并发性能。自旋锁则是，当前线程在获取锁时，如果发现锁已经被其他线程占有， 它不马上阻塞自己，在不放弃 CPU使用权的情况下，多次尝试获取(默认次数是 10，可 以使用 -XX:PreBlockSpinsh 参数设置该值)，很有可能在后面几次尝试中其他线程己经释 放了锁 。 如果尝试指定的次数后仍没有获取到锁则当前线程才会被阻塞挂起 。 由此看来自 旋锁是使用 CPU 时间换 取线程阻塞与调度的开销，但是很有可能这些 CPU 时间 白白浪费 了。